# Feature Contract - Hardware Sensor Fidelity
# Prevents the companion app from returning simulated data when connected to real hardware.
#
# AUDIT FINDING: transport.rs read_sensors() returns fake data for most sensors
# even on Serial connections, and Bluetooth silently falls back to read_simulated().
# This contract makes those patterns a build-blocking violation.

contract_meta:
  id: feature_sensors
  version: 1
  created_from_spec: "Hardware sensor fidelity audit"
  covers_reqs:
    - SENSOR-001
    - SENSOR-002
    - SENSOR-003
    - SENSOR-004
    - SENSOR-005
    - SENSOR-006
  owner: "mbot-ruvector-team"

llm_policy:
  enforce: true
  llm_may_modify_non_negotiables: false
  override_phrase: "override_contract: feature_sensors"

# ============================================
# Architecture Invariants
# ============================================

rules:
  non_negotiable:
    - id: SENSOR-001
      title: "Serial transport must use protocol commands for ALL sensors"
      rationale: >
        When connected via USB serial to real mBot2 hardware, read_sensors() must
        send protocol commands for every sensor type (ultrasonic, sound, light, gyro,
        quad RGB). Returning Default::default() or simulated values for any sensor
        field defeats the purpose of a hardware connection.
      scope:
        - "crates/mbot-companion/src/transport.rs"
      behavior:
        forbidden_patterns:
          - pattern: /Serial.*read_simulated/
            message: "Serial transport must not call read_simulated(). Send protocol commands instead."
          - pattern: /Serial.*Default::default\(\)/
            message: "Serial transport must not use Default::default() for sensor fields. Read from hardware."
          - pattern: /TransportInner::Serial.*=>.*read_simulated/
            message: "Serial match arm must not fall back to read_simulated() on error."
        required_patterns:
          - pattern: /read_ultrasonic_cmd|protocol::read_ultrasonic/
            message: "Serial must send ultrasonic read command"
          - pattern: /read_sound_cmd|protocol::read_sound/
            message: "Serial must send sound sensor read command"
          - pattern: /read_light_cmd|protocol::read_light/
            message: "Serial must send light sensor read command"
          - pattern: /read_gyro_cmd|protocol::read_gyro/
            message: "Serial must send gyro read command"
          - pattern: /read_quad_rgb_cmd|protocol::read_quad_rgb/
            message: "Serial must send quad RGB read command"
        example_violation: |
          // BAD: Only reads ultrasonic, defaults everything else
          TransportInner::Serial(serial) => {
              let cmd = protocol::read_ultrasonic_cmd();
              serial.port.write_all(&cmd)?;
              // ...
              Ok(MBotSensors {
                  ultrasonic_cm: distance,
                  ..Default::default()  // <-- VIOLATION: fakes all other sensors
              })
          }
        example_compliant: |
          // GOOD: Reads all sensors via protocol commands
          TransportInner::Serial(serial) => {
              let ultrasonic = self.read_serial_sensor(serial, protocol::read_ultrasonic_cmd())?;
              let sound = self.read_serial_sensor(serial, protocol::read_sound_cmd())?;
              let light = self.read_serial_sensor(serial, protocol::read_light_cmd())?;
              let gyro = self.read_serial_sensor(serial, protocol::read_gyro_cmd(3))?;
              let quad_rgb = self.read_serial_sensor(serial, protocol::read_quad_rgb_cmd())?;
              Ok(MBotSensors {
                  ultrasonic_cm: ultrasonic,
                  sound_level: sound,
                  light_level: light,
                  gyro_z: gyro,
                  quad_rgb: quad_rgb,
                  ..
              })
          }

    - id: SENSOR-002
      title: "Bluetooth transport must NOT silently fall back to simulated data"
      rationale: >
        The Bluetooth match arm currently calls self.read_simulated() directly,
        meaning a user who connects via Bluetooth gets fake data with no warning.
        Bluetooth must either read from the BLE notification characteristic or
        return an explicit error so the user knows sensors are not working.
      scope:
        - "crates/mbot-companion/src/transport.rs"
      behavior:
        forbidden_patterns:
          - pattern: /Bluetooth.*read_simulated/
            message: "Bluetooth transport must not silently use simulated data"
          - pattern: /TransportInner::Bluetooth.*=>.*read_simulated/
            message: "Bluetooth match arm must not call read_simulated()"
        required_patterns:
          - pattern: /Bluetooth.*characteristic|Bluetooth.*notify|Bluetooth.*read_value/
            message: "Bluetooth must read from BLE characteristic"
        example_violation: |
          // BAD: Bluetooth silently returns fake data
          TransportInner::Bluetooth(_bt) => {
              // TODO: Read from Bluetooth notification characteristic
              self.read_simulated()  // <-- VIOLATION: user thinks data is real
          }
        example_compliant: |
          // GOOD: Bluetooth reads from hardware or returns error
          TransportInner::Bluetooth(bt) => {
              bt.read_characteristic(SENSOR_UUID)
                  .map_err(|e| anyhow!("Bluetooth sensor read failed: {}", e))
          }

    - id: SENSOR-003
      title: "Failed sensor reads must use last-known-good values, not hardcoded defaults"
      rationale: >
        When a sensor read fails (timeout, corrupted response), the code must log
        the failure and use the last successfully read value. Hardcoding magic
        numbers like 100.0, 0.5, or 0.0 hides failures and produces misleading data.
      scope:
        - "crates/mbot-companion/src/transport.rs"
      behavior:
        forbidden_patterns:
          - pattern: /unwrap_or\(100\.0\)/
            message: "Do not use hardcoded 100.0 as fallback. Use last-known-good value."
          - pattern: /unwrap_or\(0\.5\)/
            message: "Do not use hardcoded 0.5 as fallback. Use last-known-good value."
          - pattern: /unwrap_or\(0\.0\)/
            message: "Do not use hardcoded 0.0 as fallback. Use last-known-good value."
        required_patterns:
          - pattern: /last_known|last_good|previous_reading|cached_sensor/
            message: "Must maintain last-known-good sensor values for fallback"
        example_violation: |
          let distance = protocol::parse_ultrasonic_response(&buf)
              .unwrap_or(100.0);  // <-- VIOLATION: hides failure with magic number
        example_compliant: |
          let distance = match protocol::parse_ultrasonic_response(&buf) {
              Some(d) => {
                  self.last_known.ultrasonic_cm = d;
                  d
              }
              None => {
                  warn!("Ultrasonic read failed, using last-known-good: {}", self.last_known.ultrasonic_cm);
                  self.last_known.ultrasonic_cm
              }
          };

    - id: SENSOR-004
      title: "Dashboard must display SIMULATION indicator when showing simulated data"
      rationale: >
        If any sensor data is simulated (either because the transport is Simulated
        or because a real transport fell back to simulated values), the web dashboard
        must clearly show a 'SIMULATION' indicator so the user is never deceived.
      scope:
        - "web/server.js"
        - "web/public/index.html"
      behavior:
        required_patterns:
          - pattern: /simulation|simulated|data-source/i
            message: "Dashboard must indicate when data is simulated"
        example_violation: |
          <!-- BAD: No indication that data might be fake -->
          <div id="sensor-display">
            <span>Distance: ${distance} cm</span>
          </div>
        example_compliant: |
          <!-- GOOD: Clear simulation indicator -->
          <div id="sensor-display">
            <span class="simulation-badge" data-testid="simulation-indicator"
                  style="display: ${isSimulated ? 'block' : 'none'}">
              SIMULATION
            </span>
            <span>Distance: ${distance} cm</span>
          </div>

  soft:
    - id: SENSOR-005
      title: "Protocol read commands must exist for all sensor types"
      suggestion: >
        protocol.rs should have read command builders for all five sensor types:
        ultrasonic, sound, light, gyro, and quad RGB. Currently missing:
        read_sound_cmd() and read_light_cmd().
      scope:
        - "crates/mbot-companion/src/protocol.rs"

    - id: SENSOR-006
      title: "Sensor diagnostic mode (--diagnose) should test each sensor individually"
      suggestion: >
        A --diagnose CLI flag should test each sensor one at a time and report
        which sensors are responding and which are not. This helps users debug
        hardware connection issues without needing to interpret raw protocol data.
      scope:
        - "crates/mbot-companion/src/transport.rs"
        - "crates/mbot-companion/src/main.rs"

# ============================================
# Acceptance Criteria (Gherkin)
# ============================================

acceptance_criteria:
  feature: "Hardware Sensor Fidelity"
  actor: "mBot2 companion app user"
  benefit: "I see real sensor data when connected to real hardware"

  scenarios:
    - name: "All sensors read from hardware via serial"
      given:
        - "the companion app is connected via --serial /dev/ttyUSB0"
        - "the mBot2 hardware is powered on"
      when:
        - "the main loop calls read_sensors()"
      then:
        - "protocol commands are sent for ultrasonic, sound, light, gyro, and quad RGB"
        - "no field in MBotSensors uses Default::default()"
        - "no call to read_simulated() occurs"

    - name: "Bluetooth reads from BLE characteristic"
      given:
        - "the companion app is connected via --bluetooth"
        - "BLE services have been discovered"
      when:
        - "the main loop calls read_sensors()"
      then:
        - "sensor data is read from the BLE notification characteristic"
        - "read_simulated() is NOT called"
        - "OR an explicit error is returned if BLE read fails"

    - name: "Failed sensor read uses last-known-good value"
      given:
        - "the companion app is connected via serial"
        - "a previous successful ultrasonic read returned 42.5 cm"
      when:
        - "the next ultrasonic read times out or returns corrupt data"
      then:
        - "the failure is logged with a warning"
        - "the returned MBotSensors.ultrasonic_cm is 42.5 (last-known-good)"
        - "no hardcoded value like 100.0 or 0.0 is substituted"

    - name: "Dashboard shows SIMULATION badge when data is simulated"
      given:
        - "the companion app is running with --simulate"
        - "the web dashboard is open"
      when:
        - "sensor data is displayed"
      then:
        - "a visible SIMULATION indicator is shown"
        - "the indicator has data-testid='simulation-indicator'"

    - name: "Diagnostic mode tests each sensor"
      given:
        - "the companion app is connected via serial"
      when:
        - "the user runs mbot-companion --serial /dev/ttyUSB0 --diagnose"
      then:
        - "each sensor is tested individually: ultrasonic, sound, light, gyro, quad RGB"
        - "results show PASS or FAIL per sensor"
        - "failed sensors include the error reason"

    - name: "Simulated mode is clearly labeled"
      given:
        - "the user runs mbot-companion --simulate"
      when:
        - "the main loop starts"
      then:
        - "the console output includes 'SIMULATION' in the banner"
        - "read_simulated() is only called from TransportInner::Simulated"

# ============================================
# data-testid Requirements
# ============================================

test_ids:
  - element: "Simulation indicator badge"
    testid: "simulation-indicator"
    purpose: "Shows when data source is simulated, not real hardware"

  - element: "Data source label"
    testid: "data-source-label"
    purpose: "Shows 'Serial', 'Bluetooth', or 'Simulated'"

  - element: "Sensor health per sensor"
    testid: "sensor-health-{sensor}"
    purpose: "Green/red indicator per sensor (ultrasonic, sound, light, gyro, quad-rgb)"

  - element: "Last read timestamp"
    testid: "sensor-last-read-{sensor}"
    purpose: "When each sensor was last successfully read"

# ============================================
# Journey References
# ============================================

journeys:
  - id: J-SENSOR-ALL-REAL
    description: "User connects mBot2 via serial. All sensors return real hardware values. No simulated data."
    criticality: critical
    test_file: "tests/journeys/sensor-all-real.journey.spec.ts"
    covers: [SENSOR-001, SENSOR-002, SENSOR-003]

  - id: J-SENSOR-DIAGNOSE
    description: "User runs --diagnose. Each sensor is tested. Results show which work and which don't."
    criticality: important
    test_file: "tests/journeys/sensor-diagnose.journey.spec.ts"
    covers: [SENSOR-006]

# ============================================
# E2E Test Reference
# ============================================

e2e_tests:
  - file: "tests/contracts/sensor_fidelity.rs"
    covers: [SENSOR-001, SENSOR-002, SENSOR-003, SENSOR-005]
    scenarios:
      - "Serial match arm does not call read_simulated"
      - "Serial match arm does not use Default::default() for sensor struct"
      - "Bluetooth match arm does not call read_simulated"
      - "Protocol has read commands for all five sensor types"
      - "Transport calls all protocol read functions"

# ============================================
# Compliance Checklist
# ============================================

compliance_checklist:
  before_editing_files:
    - question: "Modifying read_sensors() in transport.rs?"
      if_yes: "Ensure Serial and Bluetooth arms send real protocol commands (SENSOR-001, SENSOR-002)"
    - question: "Adding a fallback value for a sensor read?"
      if_yes: "Use last-known-good, not a hardcoded number (SENSOR-003)"
    - question: "Adding new sensor data to the dashboard?"
      if_yes: "Include simulation indicator if data might be simulated (SENSOR-004)"
    - question: "Adding a new sensor type?"
      if_yes: "Add protocol command in protocol.rs AND call it in transport.rs (SENSOR-005)"

# ============================================
# Definition of Done
# ============================================

definition_of_done:
  - "Serial read_sensors() sends protocol commands for all 5 sensor types"
  - "Bluetooth read_sensors() reads from BLE characteristic or returns error"
  - "No call to read_simulated() from Serial or Bluetooth match arms"
  - "Failed reads use last-known-good values with warning log"
  - "Dashboard shows SIMULATION indicator when data is simulated"
  - "Protocol has read commands for ultrasonic, sound, light, gyro, quad RGB"
  - "All contract tests in sensor_fidelity.rs pass"
  - "All Gherkin scenarios pass"
